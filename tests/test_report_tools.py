"""Tests for internal report management tools"""

import json
import tempfile
from pathlib import Path

import pytest

from ai_assist.report_tools import ReportTools


@pytest.fixture
def temp_reports():
    """Create a temporary directory for reports"""
    with tempfile.TemporaryDirectory() as tmpdir:
        yield Path(tmpdir)


@pytest.fixture
def report_tools(temp_reports):
    """Create ReportTools instance with temp directory"""
    return ReportTools(reports_dir=temp_reports)


class TestReportTools:
    """Tests for ReportTools class"""

    def test_initialization(self, report_tools, temp_reports):
        """Test that ReportTools initializes correctly"""
        assert report_tools.reports_dir == temp_reports
        assert temp_reports.exists()

    def test_tilde_expansion_in_env_var(self, monkeypatch, tmp_path):
        """Test that tilde in AI_ASSIST_REPORTS_DIR is properly expanded"""

        # Set env var with tilde
        test_dir = tmp_path / "test-reports"
        monkeypatch.setenv("AI_ASSIST_REPORTS_DIR", f"~/{test_dir.name}")

        # Create ReportTools - it should expand the tilde
        rt = ReportTools()

        # Path should be absolute and not contain literal ~
        assert rt.reports_dir.is_absolute()
        assert "~" not in str(rt.reports_dir)
        # Should have expanded to home directory
        assert str(rt.reports_dir).startswith(str(Path.home()))

    def test_get_tool_definitions(self, report_tools):
        """Test that tool definitions are returned"""
        tools = report_tools.get_tool_definitions()
        assert len(tools) == 5
        assert all(tool["_server"] == "internal" for tool in tools)

        tool_names = [tool["name"] for tool in tools]
        assert "internal__write_report" in tool_names
        assert "internal__append_to_report" in tool_names
        assert "internal__read_report" in tool_names
        assert "internal__list_reports" in tool_names
        assert "internal__delete_report" in tool_names


class TestWriteReport:
    """Tests for write_report functionality"""

    @pytest.mark.asyncio
    async def test_write_report_creates_file(self, report_tools, temp_reports):
        """Test that write_report creates a markdown file"""
        result = await report_tools.execute_tool(
            "write_report", {"name": "test-report", "content": "# Test Report\n\nContent here."}
        )

        assert "test-report" in result
        assert "written to" in result

        # Verify file exists
        report_file = temp_reports / "test-report.md"
        assert report_file.exists()

        # Verify content
        content = report_file.read_text()
        assert "# Test Report" in content
        assert "Content here." in content

    @pytest.mark.asyncio
    async def test_write_report_includes_timestamp(self, report_tools, temp_reports):
        """Test that write_report adds timestamp metadata"""
        await report_tools.execute_tool("write_report", {"name": "timestamped", "content": "# Report"})

        report_file = temp_reports / "timestamped.md"
        content = report_file.read_text()

        # Check for timestamp comment
        assert "<!-- Generated by AI Assistant on" in content
        assert "20" in content  # Year should be in 2000s

    @pytest.mark.asyncio
    async def test_write_report_overwrites_existing(self, report_tools, temp_reports):
        """Test that write_report overwrites existing files"""
        # Create initial report
        await report_tools.execute_tool("write_report", {"name": "overwrite-test", "content": "# Original Content"})

        # Overwrite with new content
        await report_tools.execute_tool("write_report", {"name": "overwrite-test", "content": "# New Content"})

        report_file = temp_reports / "overwrite-test.md"
        content = report_file.read_text()

        # Should have new content, not original
        assert "# New Content" in content
        assert "# Original Content" not in content


class TestAppendToReport:
    """Tests for append_to_report functionality"""

    @pytest.mark.asyncio
    async def test_append_to_existing_report(self, report_tools, temp_reports):
        """Test appending to an existing report"""
        # Create initial report
        await report_tools.execute_tool("write_report", {"name": "append-test", "content": "# Initial Content"})

        # Append to it
        result = await report_tools.execute_tool(
            "append_to_report", {"name": "append-test", "content": "Additional content"}
        )

        assert "Content appended" in result

        report_file = temp_reports / "append-test.md"
        content = report_file.read_text()

        assert "# Initial Content" in content
        assert "Additional content" in content

    @pytest.mark.asyncio
    async def test_append_with_section_header(self, report_tools, temp_reports):
        """Test appending with a section header"""
        await report_tools.execute_tool("write_report", {"name": "sections", "content": "# Report"})

        await report_tools.execute_tool(
            "append_to_report", {"name": "sections", "content": "Section content", "section": "New Section"}
        )

        report_file = temp_reports / "sections.md"
        content = report_file.read_text()

        assert "## New Section" in content
        assert "Section content" in content

    @pytest.mark.asyncio
    async def test_append_creates_file_if_not_exists(self, report_tools, temp_reports):
        """Test that append creates file if it doesn't exist"""
        result = await report_tools.execute_tool("append_to_report", {"name": "new-report", "content": "First content"})

        assert "Content appended" in result

        report_file = temp_reports / "new-report.md"
        assert report_file.exists()
        content = report_file.read_text()
        assert "First content" in content


class TestReadReport:
    """Tests for read_report functionality"""

    @pytest.mark.asyncio
    async def test_read_existing_report(self, report_tools, temp_reports):
        """Test reading an existing report"""
        await report_tools.execute_tool("write_report", {"name": "readable", "content": "# Readable Report"})

        result = await report_tools.execute_tool("read_report", {"name": "readable"})

        assert "# Readable Report" in result

    @pytest.mark.asyncio
    async def test_read_nonexistent_report(self, report_tools):
        """Test reading a non-existent report"""
        result = await report_tools.execute_tool("read_report", {"name": "nonexistent"})

        assert "not found" in result


class TestListReports:
    """Tests for list_reports functionality"""

    @pytest.mark.asyncio
    async def test_list_reports_empty_directory(self, report_tools):
        """Test listing reports in empty directory"""
        result = await report_tools.execute_tool("list_reports", {})

        reports = json.loads(result)
        assert isinstance(reports, list)
        assert len(reports) == 0

    @pytest.mark.asyncio
    async def test_list_reports_with_files(self, report_tools):
        """Test listing reports with files"""
        await report_tools.execute_tool("write_report", {"name": "report1", "content": "Content 1"})
        await report_tools.execute_tool("write_report", {"name": "report2", "content": "Content 2"})

        result = await report_tools.execute_tool("list_reports", {})

        reports = json.loads(result)
        assert len(reports) == 2

        # Check metadata
        assert all("name" in r for r in reports)
        assert all("size" in r for r in reports)
        assert all("modified" in r for r in reports)

        names = [r["name"] for r in reports]
        assert "report1" in names
        assert "report2" in names


class TestDeleteReport:
    """Tests for delete_report functionality"""

    @pytest.mark.asyncio
    async def test_delete_existing_report(self, report_tools, temp_reports):
        """Test deleting an existing report"""
        await report_tools.execute_tool("write_report", {"name": "deleteme", "content": "Content"})

        report_file = temp_reports / "deleteme.md"
        assert report_file.exists()

        result = await report_tools.execute_tool("delete_report", {"name": "deleteme"})

        assert "deleted" in result
        assert not report_file.exists()

    @pytest.mark.asyncio
    async def test_delete_nonexistent_report(self, report_tools):
        """Test deleting a non-existent report"""
        result = await report_tools.execute_tool("delete_report", {"name": "nonexistent"})

        assert "not found" in result


class TestToolDefinitionsFormat:

    def test_write_report_has_format_property(self, report_tools):
        tools = report_tools.get_tool_definitions()
        write_tool = next(t for t in tools if t["name"] == "internal__write_report")
        fmt_prop = write_tool["input_schema"]["properties"]["format"]
        assert fmt_prop["enum"] == ["csv", "jsonl", "md", "tsv"]

    def test_append_report_has_format_property(self, report_tools):
        tools = report_tools.get_tool_definitions()
        append_tool = next(t for t in tools if t["name"] == "internal__append_to_report")
        fmt_prop = append_tool["input_schema"]["properties"]["format"]
        assert fmt_prop["enum"] == ["csv", "jsonl", "md", "tsv"]

    def test_read_report_has_format_property(self, report_tools):
        tools = report_tools.get_tool_definitions()
        read_tool = next(t for t in tools if t["name"] == "internal__read_report")
        fmt_prop = read_tool["input_schema"]["properties"]["format"]
        assert fmt_prop["enum"] == ["csv", "jsonl", "md", "tsv"]

    def test_delete_report_has_format_property(self, report_tools):
        tools = report_tools.get_tool_definitions()
        delete_tool = next(t for t in tools if t["name"] == "internal__delete_report")
        fmt_prop = delete_tool["input_schema"]["properties"]["format"]
        assert fmt_prop["enum"] == ["csv", "jsonl", "md", "tsv"]


class TestWriteReportJsonl:

    @pytest.mark.asyncio
    async def test_write_jsonl(self, report_tools, temp_reports):
        content = '{"event": "build", "status": "pass"}\n{"event": "test", "status": "fail"}'
        result = await report_tools.execute_tool(
            "write_report", {"name": "events", "content": content, "format": "jsonl"}
        )
        assert "events" in result
        assert "jsonl" in result
        report_file = temp_reports / "events.jsonl"
        assert report_file.exists()
        text = report_file.read_text()
        assert "<!--" not in text
        lines = text.strip().splitlines()
        assert len(lines) == 2
        json.loads(lines[0])

    @pytest.mark.asyncio
    async def test_write_jsonl_invalid_json(self, report_tools):
        result = await report_tools.execute_tool(
            "write_report", {"name": "bad", "content": "not json", "format": "jsonl"}
        )
        assert "Error" in result
        assert "Invalid JSON" in result

    @pytest.mark.asyncio
    async def test_write_jsonl_no_header(self, report_tools, temp_reports):
        content = '{"key": "value"}'
        await report_tools.execute_tool("write_report", {"name": "headerless", "content": content, "format": "jsonl"})
        text = (temp_reports / "headerless.jsonl").read_text()
        assert not text.startswith("<!--")


class TestWriteReportCsv:

    @pytest.mark.asyncio
    async def test_write_csv(self, report_tools, temp_reports):
        content = "name,status,date\njob1,pass,2024-01-01\njob2,fail,2024-01-02"
        result = await report_tools.execute_tool(
            "write_report", {"name": "results", "content": content, "format": "csv"}
        )
        assert "results" in result
        report_file = temp_reports / "results.csv"
        assert report_file.exists()
        lines = report_file.read_text().strip().splitlines()
        assert lines[0] == "name,status,date"
        assert len(lines) == 3


class TestWriteReportTsv:

    @pytest.mark.asyncio
    async def test_write_tsv(self, report_tools, temp_reports):
        content = "name\tstatus\njob1\tpass"
        await report_tools.execute_tool("write_report", {"name": "tab-data", "content": content, "format": "tsv"})
        report_file = temp_reports / "tab-data.tsv"
        assert report_file.exists()
        lines = report_file.read_text().strip().splitlines()
        assert len(lines) == 2


class TestAppendToReportJsonl:

    @pytest.mark.asyncio
    async def test_append_jsonl(self, report_tools, temp_reports):
        await report_tools.execute_tool("write_report", {"name": "log", "content": '{"seq": 1}', "format": "jsonl"})
        await report_tools.execute_tool("append_to_report", {"name": "log", "content": '{"seq": 2}', "format": "jsonl"})
        text = (temp_reports / "log.jsonl").read_text()
        lines = text.strip().splitlines()
        assert len(lines) == 2
        assert json.loads(lines[1])["seq"] == 2

    @pytest.mark.asyncio
    async def test_append_jsonl_validates(self, report_tools, temp_reports):
        await report_tools.execute_tool("write_report", {"name": "log", "content": '{"seq": 1}', "format": "jsonl"})
        result = await report_tools.execute_tool(
            "append_to_report", {"name": "log", "content": "not-json", "format": "jsonl"}
        )
        assert "Error" in result

    @pytest.mark.asyncio
    async def test_append_jsonl_creates_file(self, report_tools, temp_reports):
        result = await report_tools.execute_tool(
            "append_to_report", {"name": "newlog", "content": '{"first": true}', "format": "jsonl"}
        )
        assert "appended" in result
        assert (temp_reports / "newlog.jsonl").exists()


class TestAppendCsvTsv:

    @pytest.mark.asyncio
    async def test_append_csv_rows(self, report_tools, temp_reports):
        await report_tools.execute_tool("write_report", {"name": "data", "content": "a,b\n1,2", "format": "csv"})
        await report_tools.execute_tool("append_to_report", {"name": "data", "content": "3,4", "format": "csv"})
        lines = (temp_reports / "data.csv").read_text().strip().splitlines()
        assert len(lines) == 3
        assert lines[2] == "3,4"

    @pytest.mark.asyncio
    async def test_append_tsv_rows(self, report_tools, temp_reports):
        await report_tools.execute_tool("write_report", {"name": "tab", "content": "a\tb\n1\t2", "format": "tsv"})
        await report_tools.execute_tool("append_to_report", {"name": "tab", "content": "3\t4", "format": "tsv"})
        lines = (temp_reports / "tab.tsv").read_text().strip().splitlines()
        assert len(lines) == 3


class TestReadReportAutoDetect:

    @pytest.mark.asyncio
    async def test_read_auto_detects_jsonl(self, report_tools):
        await report_tools.execute_tool("write_report", {"name": "auto", "content": '{"x": 1}', "format": "jsonl"})
        result = await report_tools.execute_tool("read_report", {"name": "auto"})
        assert '"x": 1' in result

    @pytest.mark.asyncio
    async def test_read_with_explicit_format(self, report_tools):
        await report_tools.execute_tool("write_report", {"name": "explicit", "content": '{"y": 2}', "format": "jsonl"})
        result = await report_tools.execute_tool("read_report", {"name": "explicit", "format": "jsonl"})
        assert '"y": 2' in result

    @pytest.mark.asyncio
    async def test_read_ambiguous_returns_error(self, report_tools):
        await report_tools.execute_tool("write_report", {"name": "multi", "content": "# MD"})
        await report_tools.execute_tool("write_report", {"name": "multi", "content": '{"a":1}', "format": "jsonl"})
        result = await report_tools.execute_tool("read_report", {"name": "multi"})
        assert "Ambiguous" in result

    @pytest.mark.asyncio
    async def test_read_unsupported_format(self, report_tools):
        result = await report_tools.execute_tool("read_report", {"name": "x", "format": "xml"})
        assert "Unsupported" in result


class TestListReportsMultiFormat:

    @pytest.mark.asyncio
    async def test_list_includes_format_field(self, report_tools):
        await report_tools.execute_tool("write_report", {"name": "r1", "content": "# MD"})
        await report_tools.execute_tool("write_report", {"name": "r2", "content": '{"k":1}', "format": "jsonl"})
        result = await report_tools.execute_tool("list_reports", {})
        reports = json.loads(result)
        assert len(reports) == 2
        formats = {r["name"]: r["format"] for r in reports}
        assert formats["r1"] == "md"
        assert formats["r2"] == "jsonl"

    @pytest.mark.asyncio
    async def test_list_same_name_different_formats(self, report_tools):
        await report_tools.execute_tool("write_report", {"name": "shared", "content": "# MD"})
        await report_tools.execute_tool("write_report", {"name": "shared", "content": "a,b\n1,2", "format": "csv"})
        result = await report_tools.execute_tool("list_reports", {})
        reports = json.loads(result)
        shared_reports = [r for r in reports if r["name"] == "shared"]
        assert len(shared_reports) == 2


class TestDeleteReportMultiFormat:

    @pytest.mark.asyncio
    async def test_delete_auto_detects_single(self, report_tools, temp_reports):
        await report_tools.execute_tool("write_report", {"name": "del", "content": '{"x":1}', "format": "jsonl"})
        result = await report_tools.execute_tool("delete_report", {"name": "del"})
        assert "deleted" in result
        assert not (temp_reports / "del.jsonl").exists()

    @pytest.mark.asyncio
    async def test_delete_ambiguous_returns_error(self, report_tools):
        await report_tools.execute_tool("write_report", {"name": "dup", "content": "# MD"})
        await report_tools.execute_tool("write_report", {"name": "dup", "content": '{"a":1}', "format": "jsonl"})
        result = await report_tools.execute_tool("delete_report", {"name": "dup"})
        assert "Ambiguous" in result

    @pytest.mark.asyncio
    async def test_delete_with_explicit_format(self, report_tools, temp_reports):
        await report_tools.execute_tool("write_report", {"name": "dup", "content": "# MD"})
        await report_tools.execute_tool("write_report", {"name": "dup", "content": '{"a":1}', "format": "jsonl"})
        result = await report_tools.execute_tool("delete_report", {"name": "dup", "format": "jsonl"})
        assert "deleted" in result
        assert not (temp_reports / "dup.jsonl").exists()
        assert (temp_reports / "dup.md").exists()


class TestDefaultFormatBackwardCompat:

    @pytest.mark.asyncio
    async def test_write_default_is_md(self, report_tools, temp_reports):
        await report_tools.execute_tool("write_report", {"name": "compat", "content": "# Test"})
        assert (temp_reports / "compat.md").exists()
        assert not (temp_reports / "compat.jsonl").exists()

    @pytest.mark.asyncio
    async def test_append_default_is_md(self, report_tools, temp_reports):
        await report_tools.execute_tool("append_to_report", {"name": "compat2", "content": "text"})
        assert (temp_reports / "compat2.md").exists()
